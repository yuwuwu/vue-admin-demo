(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('element-ui/lib/table'), require('element-ui/lib/table-column')) :
	typeof define === 'function' && define.amd ? define(['element-ui/lib/table', 'element-ui/lib/table-column'], factory) :
	(global.Egrid = factory(global.ELEMENT.Table,global.ELEMENT.TableColumn));
}(this, (function (ElTable,ElTableColumn) { 'use strict';

ElTable = ElTable && ElTable.hasOwnProperty('default') ? ElTable['default'] : ElTable;
ElTableColumn = ElTableColumn && ElTableColumn.hasOwnProperty('default') ? ElTableColumn['default'] : ElTableColumn;

var METHOD_NAMES = ["setCurrentRow", "toggleRowSelection", "toggleRowExpansion", "clearSelection", "clearFilter", "clearSort", "doLayout", "sort"];

var methods = {};

METHOD_NAMES.forEach(function (name) {
  methods[name] = function () {
    var grid = this.$refs.grid;

    if (grid && grid[name]) {
      grid[name].apply(grid, arguments);
    }
  };
});

var methods$1 = { methods: methods };

var Text = {
  functional: true,
  props: ['row', 'col', 'column'],
  render: function render(h, _ref) {
    var _ref$props = _ref.props,
        row = _ref$props.row,
        col = _ref$props.col,
        text = _ref._v;
    var formater = col.formater;

    var v = formater && formater(row, col) || row[col.prop];
    // 解决 umd 打包 text 渲染不出来的问题，需要转成 Vnode
    return text && text(v) || v;
  }
};

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _components;

var BOOLEAN_KEYS = ['fit', 'stripe', 'border', 'show-header', 'highlight-current-row', 'default-expand-all', 'show-summary'];

var COLUMN_PROPS = {
  align: 'left',
  component: Text
};

var TYPES = ['selection', 'expand', 'index'];

var COLUMN_KEY_MAP = {
  label: 'label',
  prop: 'prop'
};

var Main = {
  render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('el-table', _vm._g(_vm._b({ ref: "grid", staticClass: "egrid", attrs: { "data": _vm.data } }, 'el-table', _vm.tableBind, false), _vm.$listeners), [_vm._l(_vm.typesColumns, function (tp) {
      return [tp.type === 'expand' ? _c('el-table-column', _vm._b({ key: tp.type, attrs: { "type": "expand" }, scopedSlots: _vm._u([{ key: "default", fn: function fn(props) {
            return [_vm._t("expand", null, null, props)];
          } }]) }, 'el-table-column', tp.props, false)) : _c('el-table-column', _vm._b({ key: tp.type, attrs: { "type": tp.type } }, 'el-table-column', tp.props, false))];
    }), _vm._v(" "), _vm._l(_vm.renderColumns, function (col) {
      return _c('el-table-column', _vm._b({ key: col.label, scopedSlots: _vm._u([{ key: "default", fn: function fn(scope) {
            return [_c(col.component, _vm._g(_vm._b({ tag: "component" }, 'component', _vm.getCptBind(scope, col), false), col.listeners))];
          } }]) }, 'el-table-column', _vm.getColBind(col), false));
    }), _vm._v(" "), _vm.slotAppend ? _c('template', { slot: "append" }, [_vm._t("append")], 2) : _vm._e()], 2);
  },
  staticRenderFns: [],
  name: 'Egrid',

  mixins: [methods$1],

  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    columns: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    columnType: [String, Array],

    columnTypeProps: Object,

    columnKeyMap: Object,

    columnsProps: Object,

    columnsSchema: Object,

    columnsHandler: Function,

    slotAppend: Boolean
  },

  computed: {
    // 处理 $attrs 里面 Boolean 类型的 prop 和统一 prop 命名 
    tableBind: function tableBind() {
      var $attrs = this.$attrs;

      var bind = {};
      Object.keys($attrs).forEach(function (key) {
        var v = $attrs[key];
        var uniformKey = key.replace(/([A-Z])/, '-$1').toLowerCase();
        bind[key] = ~BOOLEAN_KEYS.indexOf(uniformKey) && v === '' ? true : v;
      });
      return bind;
    },
    renderColumns: function renderColumns() {
      var columns = this.columns,
          columnKeyMap = this.columnKeyMap,
          columnsHandler = this.columnsHandler,
          props = this.columnsProps,
          schema = this.columnsSchema;

      var map = Object.assign({}, COLUMN_KEY_MAP, columnKeyMap);
      var renderColumns = columns.map(function (col) {
        var mix = schema && schema[col[map.label]] || {};
        var it = Object.assign({}, COLUMN_PROPS, props, col, mix);
        it.label = it[map.label];
        it.prop = it[map.prop];
        return it;
      });
      return columnsHandler && columnsHandler(renderColumns) || renderColumns;
    },


    // 用于渲染特殊列
    typesColumns: function typesColumns() {
      var type = this.columnType,
          columnTypeProps = this.columnTypeProps;

      var typeColums = [];
      if (typeof type === 'string' && ~TYPES.indexOf(type)) {
        typeColums = [type];
      }
      if (Array.isArray(type)) {
        typeColums = type.filter(function (it) {
          return ~TYPES.indexOf(it);
        });
      }
      var map = columnTypeProps || {};
      return typeColums.map(function (type) {
        return {
          type: type,
          props: map[type]
        };
      });
    }
  },

  methods: {
    getColBind: function getColBind(col) {
      var bind = Object.assign({}, col);
      delete bind.component;
      delete bind.listeners;
      delete bind.propsHandler;
      return bind;
    },
    getCptBind: function getCptBind(_ref, col) {
      var row = _ref.row,
          column = _ref.column;

      var props = { row: row, col: col, column: column };
      var handler = col.propsHandler;
      return handler && handler(props) || props;
    }
  },

  components: (_components = {}, defineProperty(_components, ElTable.name, ElTable), defineProperty(_components, ElTableColumn.name, ElTableColumn), _components)
};

Main.install = function (Vue) {
  Vue.component(Main.name, Main);
};
Main._mixinsMethods = methods$1;

return Main;

})));
